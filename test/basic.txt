## Set the directive prefix to '##'. Alternatively you
## can use the `-p` command-line option to set the prefix.
##
## The prefix directive is unique in that the literal string
## 'FCHK PREFIX' (actually with a hyphen between FCHK and PREFIX
## as seen below, but ## we can’t write it like that here, since
## it would be parsed as a directive if we did that) is always
## recognised as a directive, irrespective of what comes before
## it in the same line. This is required to bootstrap the prefix.
##
## FCHK-PREFIX ##

## Run this command on this file before checking it.
## R sed /^#/d %s

## This text is ignored because it does not resemble a
## valid directive, even though it starts with the directive
## prefix '##'.

## * Lorem ipsum dolor sit amet
Lorem ipsum dolor sit amet

## Check should ignore spaces.
## * Lorem    ipsum    dolor sit amet
Lorem ipsum     dolor sit    amet

## Check consecutive lines
## * A
## + B
## + C
A
B
C

## Check using a regular expression
## re* [0-9]+
## re+ [a-z]+
1234567890
asdfghjkl

## Check that a line does *not* contain a pattern.
##
## This attaches to preceding (re)* and (re)+ directives and
## checks the same line that those directives matched.
##
## * foo
## ! foobar
## re! [0-9]+
foo bar

## Named capture groups can be used in subsequent directives.
##
## Since it doesn’t make sense to have anything after a `$` in
## a regular expression anyway, the syntax $name can be used as
## an alternative to \k<name> if the name matches the regular
## expression `[a-zA-Z0-9_]+`.
##
## * Q
## re+ %(?<foo>[0-9]+) = call
## re+ %[0-9]+ = add %\k<foo>, %\k<foo>
## re+ %[0-9]+ = add %$foo, %$foo
Q
%123 = call @bar()
%456 = add %123, %123
%789 = add %123, %123

## The `d` directive can be used to define a variable / capture
## group manually w/o having to match a pattern first.
##
## d tmp %[0-9]+
## * R
## re+ $tmp = add $tmp, $tmp
R
%1 = add %2, %3

## Variable substitution behaves differently depending on whether
## the variable is used by the same pattern that defines it or not.
##
## For example, in a pattern such as `(?<foo>\d+) $foo`, the string
## `$foo` is rewritten to `\k<foo>` before the pattern is handed to
## the regex engine.
##
## However, when `$foo` (or `\k<foo>`) is used in a pattern after
## that, fchk will substitute the value that was bound to it in the
## pattern that defined it; e.g., if the value ended up being `123`,
## then `$foo` is replaced with `123`.
##
## As a result of this, if a variable’s value resembles a regular
## expression, then it will be incorporated into the pattern as a
## RE. This behaviour is intended since it allows you to split long
## regexes into smaller parts. However, if you instead want to match
## the *literal* value of a variable, then you can escape its value
## using `$$`, e.g. `$$foo`.
##
## d bar \d+
## * S
## re+ $$bar $bar $$bar
S
\d+ 12345 \d+

## Attempting to redefine an already existing variable, whether
## explicitly using `d` or implicitly by naming it in a pattern,
## is an error. Use the `u` directive to undefine a variable.
##
## u tmp
## * T
## re+ (?<tmp>\d+) \+ $tmp
T
42 + 42

## If you have been using a lot of variables and want to reuse
## them, you can write `u *` to undefine *all* variables.
##
## u *
## * foobarbaz
## re+ (?<tmp>\d+) - (?<foo>\d+) = $foo - $tmp
foobarbaz
42 - 43 = 43 - 42