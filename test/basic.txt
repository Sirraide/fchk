## FCHK-PREFIX ##
## R sed /^#/d %s

## This comment is ignored because it does not
## resemble a valid directive, even though it
## starts with the directive prefix.

## * Lorem ipsum dolor sit amet
Lorem ipsum dolor sit amet

## Check should ignore spaces.
## * Lorem    ipsum dolor sit amet
Lorem ipsum     dolor sit    amet

## Check consecutive lines
## * A
## + B
## + C
A
B
C

## Check using a regular expression
## re* [0-9]+
## re+ [a-z]+
1234567890
asdfghjkl

## Check that a line does *not* contain a pattern.
##
## This attaches to preceding (re)* and (re)+ directives and
## checks the same line that those directives matched.
##
## * foo
## ! foobar
## re! [0-9]+
foo bar

## Named capture groups can be used in subsequent directives.
##
## Since it doesn’t make sense to have anything after a `$` in
## a regular expression anyway, the syntax $name can be used as
## an alternative to \k<name> if the name matches the regular
## expression `[a-zA-Z0-9_]+`.
##
## * Q
## re+ %(?<foo>[0-9]+) = call
## re+ %[0-9]+ = add %\k<foo>, %\k<foo>
## re+ %[0-9]+ = add %$foo, %$foo
Q
%123 = call @bar()
%456 = add %123, %123
%789 = add %123, %123

## The `d` directive can be used to define a variable / capture
## group manually w/o having to match a pattern first.
##
## d tmp %[0-9]+
## * R
## re+ $tmp = add $tmp, $tmp
R
%1 = add %2, %3

## Variable substitution behaves differently depending on whether
## the variable is used by the same pattern that defines it or not.
##
## For example, in a pattern such as `(?<foo>\d+) $foo`, the string
## `$foo` is rewritten to `\k<foo>` before the pattern is handed to
## the regex engine.
##
## However, when `$foo` (or `\k<foo>`) is used in a pattern after
## that, fchk will substitute the value that was bound to it in the
## pattern that defined it; e.g., if the value ended up being `123`,
## then `$foo` is replaced with `123`.
##
## As a result of this, if a variable’s value resembles a regular
## expression, then it will be incorporated into the pattern as a
## RE. This behaviour is intended since it allows you to split long
## regexes into smaller parts. However, if you instead want to match
## the *literal* value of a variable, then you can escape its value
## using `$$`, e.g. `$$foo`.
##
## d bar \d+
## * S
## re+ $$bar $bar $$bar
S
\d+ 12345 \d+
